@*
 * Copyright Â© 2015-2019 the contributors (see Contributors.md).
 *
 * This file is part of Knora.
 *
 * Knora is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Knora is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public
 * License along with Knora.  If not, see <http://www.gnu.org/licenses/>.
 *@

@import org.knora.webapi._
@import org.knora.webapi.util._
@import org.knora.webapi.util.clientapi._
@import org.knora.webapi.messages.v2.responder.ontologymessages.Cardinality._

@(classDef: ClientClassDefinition,
  interfacePathInClass: String)

@makeTypeScriptType(objectType: ClientObjectType) = @{
    objectType match {
        case StringLiteral => "string"
        case BooleanLiteral => "boolean"
        case IntegerLiteral => "number"
        case DecimalLiteral => "number"
        case UriLiteral => "string"
        case DateTimeStampLiteral => "string"
        case classRef: ClassRef => "I" + classRef.className
        case other => throw ClientApiGenerationException(s"Type $other not yet supported")
    }
}

@makeDefaultValue(objectType: ClientObjectType, cardinality: Cardinality) = @{
    if (cardinality == MayHaveMany || cardinality == MustHaveSome) {
        "[]"
    } else {
        objectType match {
           case StringLiteral => "\"\""
           case BooleanLiteral => "false"
           case IntegerLiteral => "0"
           case DecimalLiteral => "0"
           case DateTimeStampLiteral => "\"\""
           case classRef: ClassRef => "null"
           case other => throw ClientApiGenerationException(s"Type $other not supported in this template")
        }
    }
}

@wrapInArrayForCardinality(typeScriptType: String, cardinality: Cardinality) = @{
    if (cardinality == MayHaveMany || cardinality == MustHaveSome) {
        s"[$typeScriptType]"
    } else {
        typeScriptType
    }
}

@addForCardinality(typeScriptType: String, cardinality: Cardinality) = @{
    if (cardinality == MayHaveOne) {
        s"$typeScriptType?"
    } else if (cardinality == MayHaveMany || cardinality == MustHaveSome) {
        s"$typeScriptType[]"
    } else {
        typeScriptType
    }
}

import { Any, JsonObject, JsonProperty } from "json2typescript";

import { I@{classDef.className} } from "@interfacePathInClass";

@@JsonObject("@{classDef.className}")
export class @{classDef.className} implements I@{classDef.className} {
    @for(property <- classDef.properties) {
        @defining(makeTypeScriptType(property.objectType)) { typeScriptType =>
            @@JsonProperty("@{property.propertyName}", @wrapInArrayForCardinality(typeScriptType.capitalize, property.cardinality))
            public @{property.propertyName}: @addForCardinality(typeScriptType, property.cardinality) = @makeDefaultValue(property.objectType, property.cardinality);
        }
    }
}
